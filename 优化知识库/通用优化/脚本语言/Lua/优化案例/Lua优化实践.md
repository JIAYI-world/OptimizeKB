### 前言

项目组的目标是DS上20个玩家,极限情况一个玩家可以造一个终端,

一个终端最多召唤出来15只干活的SOC星灵,

极限满载情况DS上的AI会有300+大世界野外AI若干激活区域(30-70)

早期开始进行压测的战斗AI跑10-20AI已经很卡了  

早期开着TLog+Log进去10来个玩家,召唤一些星兽,客户端直接460,ds就boom了

然后老板的一个小目标=跑120个AI,野外AI+SOC对半开+玩家召出的AI

优化压力还是很大
### 大量的Lua层面的防御性代码->CPP一次调用批量处理Lua安全使用

70个AI跑了7200次IsValid判定,明显不合理

对这种相对比较基础的函数,防御性拉满,担心的前提是外部传入的对象是不正确的指针或者对象

这块也反应,这种写法在C++中不存在性能问题,但对Lua代码会带来**巨量的消耗**.

- C++是编译型语言，具有静态类型检查、手动内存管理和高级优化能力。
    
- Lua作为解释型语言，虽然开发效率高，但在执行速度上通常不如C++
    
- 可以认为Lua是排列组合调用C++代码的方式运作,实现热更新的
    

后面进行一些用例的统计,一个Tick中一个Actor对象可能会被IsValid()正确性的判断超过10次

这块看来是大量的非必要消耗操作,经过沟通AI不存在当前对象被Destroyed的操作,估指针正确性判断只需要进行一次即可

逐针对其中一个case进行优化

大家看到防御性代码已经进行6次,每次都是一次穿梭,并且返回的是UE的TArray数组,遍历消耗不如lua的table

所以针对这次调用,我们采用了如果静态绑定的操作

可将上述意义不大的防御性代码基本上0消耗

- 改造获取函数的至少四次的CPP穿梭操作->1次
    
    - _SP.GetSPGameInfo->GetCurrentRoundGameInfo( _SP.GetCurrentWorld() )->GetAllPlayerInfos()->返回 Tarray()
        
    - 一次静态绑定的lua调用GetAllCharacter_Lua,直接new出来lua的table,将判断好的对象塞入table中
        
    - lua中遍历原生table的性能要远远大于TArray的操作
        
    - 并将防御性措施提前在CPP中进行过滤掉,lua中放心的使用
        
- Unlua调用UE的C++代码方式是通过UE的反射机制来实现了,调用走的FindProperty,ProcessEvent等接口比较耗时
    
- Unlua静态绑定直接调用 C++ 函数，没有额外的反射调用开销,并可返回lua中想要的数据类型,自定义更强
    

|**对比测试**|**100次**|**1000次**|**1000次**|
|---|---|---|---|
|优化前|1.3ms|14.3ms|137.2ms|
|优化后|92.2us = 0.0922ms|3ms|39.5ms|

后面也是写了大量的UnSafe版本,函数进行路径都进行了迁移

这块静态绑定批量处理的方式一般作为优化的**后手**进行处理,会降低代码灵活性

如果大家优化到后面出现必须要走到静态绑定的情况,这块修改风险过高,可一起讨论修改

**对于一个Actor来说,如果他执行了EndPlay说明他的对象已经开始不可用,等待GC**

**后续还对Monster对象进行Lua侧的IsValid生命周期的判定,在BeginPlay()EndPlay()**

**这块就可保证Lua侧使用对象永远是可用状态,又干掉了大量的IsValid的判断**

### 大量的基础数学预算->Lua化处理

- 例1,比如简单的abs函数,MinMax,Distance函数等等,均可依靠lua的数学库进行计算
    

|**对比测试**|**100次**|**1000次**|**1000次**|
|---|---|---|---|
|优化前|336.7us|3.4ms|33ms|
|优化后|160.7us|1.6ms|15.8ms|

- 例2,ForeachMonster&&GetDistBetween,优化了判断指针的消耗,等其他类型判断,数学库纯lua计算+穿梭+位置计算的消耗
    

|**对比测试**|**100次**|**1000次**|**10000次**|
|---|---|---|---|
|优化前|335.7us|2.9ms|28.9ms|
|优化后|49.6us|489.2us|5ms|

提一些建议

- 尽量少用**Sqrt**开根号,针对与距离对比可使用FVector::DistSquared可代替FVector::Dist,用之前可以先思考下
    
- 针对两个向量算三角函数,可选择用点乘的方式来解决等等
    
- 优先使用Lua内部基础数学库
    

### 大量的穿梭调用优化->Lua化缓存

**一次Lua->C++调用链的举例**

SPGameCharacter对象在lua中调用K2_GetActorLocation()等成员函数的调用链

Lua->C++的一次调用

SPGameCharacter IndexFind->MoeGameCharacter IndexFind->反射调用K2_GetActorLocation() ->压栈返回FVector->Lua读栈,构造FVector

- 当 SPGameCharacter或者MoeGameCharacter成员过多,TableIndexFind一次不小的消耗
    
    - 如果明确知道需要访问的函数是调用CPP的函数,可通过写静态函数的方法,比如static FVector GetSPActorLocation(AActor* Actor);的方式进行获取
        
    - 但是不利于大规模更改,可针对Tick级别的函数体进行改造
        
- 利用反射进行调用也是巨量的消耗
    
    - 关键常用函数可进行必要的静态导出,绕过Unlua调用UE的反射
        
    - 可大大减少反射带来的消耗,函数接口固定后,可进行批量替换
        
    - 无法避免大的table对象的IndexFind的消耗
        

这块的处理原则是只处理热点函数

- GetSPActorType()函数,获取当前Actor对象的类型,这块加入的Dirty机制,即C++中有改动,同步到Lua中,无需进行穿梭即可从lua对象拿到类型
    
- GetNavAgentLocation() 这个函数不光拿位置还需要确认该点在寻路数据上的正确性
    
    - 之前的问题不进行缓存一帧之内50个星兽会有超过3000多次调用不合理
        
    - 针对该函数做了三层分档操作,高中低,适用于不同的业务需求,并lua缓存结果
        
- GetBuffsWithType()获取星兽身上特定的buff类型,比如,隐身等
    
    - 首先获取able组件然后再调用buff类型接口,并返回TArray
        
    - 改造成监听Buff的变化,变化就在Lua中标脏
        
    - 写针对该Buff类型的专用接口,返回类型Table
        
    - 当需要使用时候,首先检查标脏,再次从Table中找相关性buff类型
        
- 等等其他案例
    

_SP.SPSubSystemUtil.DSGetPlayerInfo(10086)

优化,静态导出+8次->1次

||**100次**|**1000次**|**10000次**|
|---|---|---|---|
|优化前|588.8us|5.7ms|58.5ms|
|优化后|36.8us|233.9us|2.3ms|

这块也是CaseByCase的优化

### 大量的遍历对全局变量进行local化

针对常用的函数进行缓存,进行local,在函数被频繁调用的或者访问的时候能消耗能大量减少

全局变量存储在全局环境表 _G 中.每次访问全局变量时.Lua 都需要在这个表中进行查找.相比之下,局部变量存储在栈上,访问速度更快

**写代码的时候在遍历中调用一些全部变量或者方法,建议local化可提升性能**

### 业务需求,对非必要核心节点进行降频处理

- lua内的减少冗余检查调用
    
- 取值能缓存就缓存
    
- if分支尽可能提前返回
    
- 行为树猛猛降频（核心-猛药）战斗4hz 休闲2hz 通用2hz
    

### 业务需求,大量异常查表调用数量级

_SP.SPConfigManager:GetConfigById("SPPetTable", "SPPetAI", 2990101)

注释掉CheckCdnUpdate的内容,后续看到这块的判断影响比较小,trace对这块耗时统计数据归属有误

||**100次**|**1000次**|**10000次**|**20000次**|
|---|---|---|---|---|
|优化前|130.6us|1.4ms|12.2ms|23.8ms|
|优化后|107.7us|1ms|10.1ms|20.4ms|

本身单次调用读表耗时也是符合预期,

由于项目组DS上表格有CDN热刷需求,估各个模块不能进行表格的查询结果进行缓存,

后续进行业务手段优化对一些**不合理调用次数**进行处理,这块耗时降下来了

**这块可对整个表格进行缓存,不能对表中某一行进行缓存**

### 业务需求,分帧处理解决耗时峰值问题-平峰波谷

避免在高峰期出现性能瓶颈,导致一些异常问题,可保证进程的运行的稳定性,

后面展开看耗时整体被压下去了,但是部分帧还是存在部分耗时较高的情况

单次耗时较高,影响系统稳定性,ds要求的就是稳定,如果出问题,影响面很大

历程

初期采用UE内置的Service节点的随机Tick的分帧方式,效果不理想,,官方这块不是很可控

后续德臻老哥,在研究走自定义的Tick,有时候一帧还是会Tick很多单位,容易拉高峰值

测试数据下来基本上与官方耗时数据基本一致但是**自定义程度更强**

主干已经提交,默认没开,求稳在Release_ds分支开启,已经让测开对功能猛猛的测

核心问题还是得先把**耗时均值**压下去

### 业务需求,SOC寻路调用次数过多

45个AI,基本上每帧耗时的寻路函数1000次左右,导致性能爆炸

后续经过业务方面不合理的优化,采用一些在不影响游戏效果的队列分帧策略

也对耗时操作条件判断进行前置,尽可能保证每次调用函数函数命中

### 小结

- 快速的迭代验证机制,先天按照跑出来的trace+csv+stats数据,进行热点修复,保证分支稳定性,晚上打包,早上自动化输出数据
    
- 这些前提建立在柯总+老板们+测开同学的DS压测环境的搭建,才能代码一天一迭代并跑数据
    
- 每次出完数据,先会快速看一波数据,找到新的瓶颈点,然后远程开会,showcase,讨论方案,分工开始优化.如此循环
    
- DS同步架构上DS的性能问题和客户端优化还是有点区别
    
    - 客户端只需要关心1P的体验,可以干很多事情,比如重要性,LOD等等
        
    - DS上单位数量级比较大,计算量也会比较大,会出现N*M这种情况,某些情况可能一个函数被调用很多次
        
    - 针对一些热点函数优化,蚊子腿多了,也会变成肉
    
- UnLua性能优化小结
    
    - 频繁调用的全局变量或函数Local化
        
    - 注意查表的次数有效性,减少无意义的查询
        
    - 对于量大高频穿透到C++函数非必要数据,可在lua中进行适当缓存
        
    - 简单的数学计算,在纯lua的环境下搞定,能少用开根号,三角函数使用需谨慎
        
    - 如果明确知道需要访问的函数是调用CPP的函数,可通过写静态函数的方法,比如static FVector GetSPActorLocation(AActor* Actor)
        
    - 针对大量的单位进行变量,并调用C++函数,可进行批量打包的方式,一次穿透批量解决问题,但需要注意指针的有效性等等
        
    - 合理化防御性代码,尽量从设计上去避免出现大量的防御性代码,lua中消耗还是不低的